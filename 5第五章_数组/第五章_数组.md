# 5.1 数组的类型定义

> ADT Array{
>
> ​	数据对象: $D=\{a_{j_1j_2\cdots j_n} | j_i=0, \cdots, b_i-1, i=1,2\cdots,n\}$;
>
> ​	数据关系: $R=\{R1, R2, \cdots, Rn\}$; 
>
> ​			 $Ri=\{<a_{j_1\cdots j_i\cdots j_n}, a_{j_1\cdots j_i+1\cdots j_n}> | 0\leqslant j_k\leqslant b_k-1, 1\leqslant k\leqslant n且k\neq i, 0\leqslant j_i\leqslant b_i-2, i=2,\cdots,n\}$;
>
> ​	基本操作: 
>
> ​		InitArray(&A, n, bound1,..., boundn)
>
> ​		DestroyArray(&A)
>
> ​		value(A, &e, index1,..., indexn)
>
> ​			初始条件: A是n维数组, e为元素变量, 随后是n个下标值. 
>
> ​			操作结果: 若各下标不超界, 则e赋值为所指定的A的元素值, 并返回OK. 
>
> ​		Assign(&A, e, index1,..., indexn)
>
> ​			初始条件: A是n维数组, e为元素变量, 随后是n个下标值. 
>
> ​			操作结果: 若各下标不超界, 则将e的值赋给所指定的A的元素, 并返回OK. 
>
> }ADT Array

# 5.2 数组的顺序表示和实现

类型特点: 

1. 只有引用型操作, 没有加工型操作;
2. 数组是多维的结构, 而存储空间是一个一维结构. 

有两种顺序映象的方式: 

1. 以行序为主序(低下标优先);
2. 以列序为主序(高下标优先). 

例如: 给定一个三维数组(2, 3, 2). 那么第一个下标取值范围是0,1; 第二个下标取值范围是0,1,2;第三个下标的取值范围是0,1. 将该数组映象到低维的次序, 以行序为主序表示从低下标(即第三个下标)开始变化: 

(0,0,0), (0,0,1), (0,1,0), (0,1,1), (0,2,0), (0,2,1)

(1,0,0), (1,0,1), (1,1,0), (1,1,1), (1,2,0), (1,2,1)

以列序为主序表示从高下标(即第一个下标)开始变化: 

(0,0,0), (1,0,0), (0,1,0), (1,1,0), (0,2,0), (1,2,0)

(0,0,1), (1,0,1), (0,1,1), (1,1,1), (0,2,1), (1,2,1)

​	一般常用"行序为主序"来存储数组. 二维数组A中任一元素$a_{i,j}$的存储位置为: 
$$
LOC[i,j] = LOC[0,0]+(b_2\times i+j)L
$$
其中LOC[0,0]成为基地址或基址. 

​	推广到一般情况, 可得到n维数组数据元素存储位置: 
$$
LOC[j_1,j_2,\cdots,j_n] = LOC[0,0,\cdots,0]+\sum_{i=1}^nc_ij_i
$$
其中$c_n=L, c_{i-1}=b_i\times c_i, 1<i\leqslant n$. LOC函数称为n维数组的映象函数, 数组元素的存储位置是其下标的线性函数. 

# 5.3 稀疏矩阵的压缩存储

​	假设m行n列的矩阵含t个非0元素, 则称
$$
\delta=\frac{t}{m\times n}
$$
为**稀疏因子**. 通常认为$\delta\leq0.05$的矩阵为**稀疏矩阵**. 

​	以常规方法, 即以二维数组表示高阶的稀疏矩阵时产生的问题:

1. 0值元素占的空间很大; 
2. 计算中进行了很多和0值的运算. 

解决上述问题的原则: 

1. 尽可能少存或者不存0值元素; 
2. 尽可能较少没有实际意义的运算; 
3. 运算方便, 即能尽可能快地找到与下标值(i,j)对应的元素; 能尽可能快地找到同一行或同一列的非0值元. 

​	在矩阵压缩处理时常遇到下列两种矩阵, 特殊矩阵和随机稀疏矩阵. 对于特殊矩阵(如三角矩阵、对角矩阵), 将矩阵中的元素线性排列即可存储, 比较简单, 不在讨论; 对于随机稀疏矩阵, 矩阵中的非零元分布不规则, 需要特殊处理. 

## 5.3.1 三元组顺序表

``` c
# define MAXSIZE	12500

typedef struct {
    int i, j; // 该非零元的行下标和列下标
    ElemType e;
}Tripe; // 三元组类型

typedef union {
    Triple data[MAXSIZE+1];
    int mu,nu,tu;
}TSMatrix; // 稀疏矩阵类型
```

例如下列矩阵可以用上述方法进行存储: 
$$
\begin{matrix}
0&3&0&0&-5\\
0&-1&0&0&0\\
6&0&0&8&0\\
\end{matrix}
$$
存储结果为: 

> (1,2,3), (1,5,-5), (2,2,-1), (3,1,6), (3,4,8)
>
> 3行5列5个非零元

​	利用上述存储方法对稀疏矩阵进行操作时可以缩减时间复杂度, 例如求转置矩阵的操作, 用常规的二维数组表示时的算法为: 

``` c
for(col=1;col<=nu;++col)
    for(row=1;row<=mu;++row)
        T[col][row] = M[row][col]
```

其时间复杂度为: $O(mu\times nu)$. 通过一个例子来说明三元组顺序表如何实现转置操作. 

给定M矩阵: 
$$
M=
\begin{bmatrix}
0&3&0&0&-5\\
0&-1&0&0&0\\
6&0&0&8&0\\
-4&0&0&0&7\\
\end{bmatrix}
$$
使用三元组顺序表存储M, 交换其行和列的下标, 得: 

| M.data | T.data |
| ------ | ------ |
| 1 2 3  | 2 1 3  |
| 1 5 -5 | 5 1 -5 |
| 2 2 -1 | 2 2 -1 |
| 3 1 6  | 1 3 6  |
| 3 4 8  | 4 3 8  |
| 4 1 -4 | 1 4 -4 |
| 4 5 7  | 5 4 7  |

​	但是上述结果并不完整, 因为在三元组顺序表中是以行序为主序存储数组的, 即元素第一个下标的变化应该从小到大, 当第一个下标相同时, 第二个下标按照从小到大的方式存储. 因为转置相当于矩阵的行和列互换, 而原矩阵的行是从小到大排列的, 根据这一特性, 为解决上述问题, 首先要确定转置后T数组每行第一个非零元素的位置(即M中每一列第一个元素在转置后在T的存放的位置), 用一个线性表来存储这个结构cPot. 当cPot确定后, 从头开始遍历M数组, 每遍历到一个元素m, 根据m的列标和cPot确定转置后元素应该在的位置, 然后cPot中对应列中的数据+1, 表示下一次遇到同一列中的元素应该存的位置. 

​	求cPot的过程是一个累加的过程. 首先初始化累加器为0, 遍历M数组, 每遍历一个元素, 将其所在列的cPot值+1. 遍历完成后(此时累加器中的值表示M数组中某一列有多少元素, 即T数组中某一行有多少元素), 第一列元素的cPot的值为1(因为转置后M的第一列变成T的第一行), 然后第i列的cPot值为i-1列的cPot值加i-1列的累加器中的值. 

| Col  | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| Num  | 2    | 2    | 0    | 1    | 2    |
| cPot | 1    | 3    | 5    | 5    | 6    |

得到cPot后, 从第一个元素开始遍历, 指针开始指向(1,2,3)的位置, 该元素列的下标为2, 查表得知在转置后的矩阵T中该元素位置应为3. 将该元素的行和列交换后存在T矩阵对应位置, cPot中2的值由3变为4. 

| M.data | T.data |
| ------ | ------ |
| 1 2 3  |        |
| 1 5 -5 |        |
| 2 2 -1 | 2 1 3  |
| 3 1 6  |        |
| 3 4 8  |        |
| 4 1 -4 |        |
| 4 5 7  |        |

| Col  | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| Num  | 2    | 2    | 0    | 1    | 2    |
| cPot | 1    | 3->4 | 5    | 5    | 6    |

后续操作类似. 算法如下: 

``` c
Status FastTransposeSMatrix(TSMatrix M, TSMatrix &T) {
    T.mu=M.nu; T.nu=M.mu; T.tu=M.tu;
    if(T.tu) {
        for(col=1; col<=M.nu; ++col) num[col]=0;
        for(t=1; t<=M.tu; ++t) ++num[M.data[t].j];
        cpot[1] = 1;
        for(col=2; col<=M.nu; ++col) 
            cpot[col] = cpot[col-1]+num[col-1];
        for(p=1; p<=M.tu; ++p) {
            col = M.data[p].j; 
            q = cpot[col];
            T.data[q].i=M.data[q].j; T.data[q].j=M.data[q].i; T.data[q].e=M.data[q].e;
            ++cpot[col];
        } // for
    } // if
    return OK;
} // FastTransposeSMatrix
```

​	三元组顺序表又称有序的双下标法, 它的特点是, 非零元在表中按行序有序存储, 因此便于进行依次顺序处理的矩阵运算. 然而, 若需随机存取某一行中的非零元, 则需从头开始进行查找. 

## 5.3.2 行逻辑链接的顺序表

​	修改前述的稀疏矩阵的结构定义, 增加一个数据成员rpos, 其值在稀疏矩阵的初始化函数中确定, 类似于上文中的cPot, 只不过列换成了行. 

``` c
# define MAXMN	500

typedef struct {
    Triple data[MAXSIZE+1];
    int rpos[MAXMN+1];
    int mu,nu,tu;
}RLSMatrix; // 行逻辑链接顺序表类型
```

用一个矩阵乘法的列子来看一下行逻辑链接的顺序表的优点. 

假定M矩阵, N矩阵, 乘积为Q矩阵. 
$$
M=
\begin{bmatrix}
0&2&0&0&3\\
0&-1&5&0&0\\
4&0&0&7&6\\
0&0&-3&0&0\\
\end{bmatrix}, 
N=
\begin{bmatrix}
0&3\\
2&4\\
1&0\\
0&0\\
0&-2\\
\end{bmatrix}, 
Q=
\begin{bmatrix}
4&2\\
3&-4\\
0&0\\
-3&0\\
\end{bmatrix} 
$$

| M.data | N.data |
| ------ | ------ |
| 1 2 2  | 1 2 3  |
| 1 5 3  | 2 1 2  |
| 2 2 -1 | 2 2 4  |
| 2 3 5  | 3 1 1  |
| 3 1 4  | 5 2 -2 |
| 3 4 7  |        |
| 3 5 6  |        |
| 4 3 -3 |        |

​	M是4行5列的矩阵, N为5行2列的矩阵, 所以Q为4行2列的矩阵. 按行来分别处理乘法, 同样需要一个累加器, 因为Q的列数为2, 所以大小为2的线性表做累加器. 初始时累加器置0. 从M中的第一个元素(1,2,2)开始计算, 列为2, 即要找到N中行为2的元素相乘并放入累加器对应位置. 根据rpos很容易找到N中第一个对应的元素(2,1,2), 数据部分相乘为4, 加入累加器第一个位置; N中向下遍历, 找到元素(2,2,4), 仍为N中第二行的元素, 将数据部分相乘为8, 加入累加器第二个位置. 此时N中第二行的所有非零元素都计算完毕, M的指针向后移, 找到元素(1,5,3). 根据rpos找到N中第5行的第一个元素(5,2,-2), 将数据部分相乘得-6, 加入累加器第二个位置. M中第一行的所有元素均已计算完成, 将累加器中的值存入Q中, 累加器置0, 进行下一行运算. 

| 累加器 |            |
| ------ | ---------- |
| 0+4=4  | 0+8+(-6)=2 |

| Q.data |      |      |
| ------ | ---- | ---- |
| 1      | 1    | 4    |
| 1      | 2    | 2    |

两个矩阵相乘(Q=M×N)的过程可大致描述如下: 

``` c
Q初始化;
if Q是非零矩阵 { // 逐行求积
    for(arow=1; arow<=M.mu; ++arow) { // 处理M的每一行
        ctemp[]=0; // 累加器清0
        计算Q中第arow行的积并存入ctemp[]中;
        将ctemp[]中非零元压缩存储到Q.data;
    } // for arow
} // if
```

``` c
Status MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix &Q) {
    if(M.nu!=N.mu) return ERROR;
    Q.mu=M.mu; Q.nu=N.nu; Q.tu=0;
    if(M.tu*N.tu!=0) { // Q是非零矩阵
        for(arow=1; arow<=M.mu; ++arow) { // 处理M的每一行
            ctemp[]=0; // 当前行各元素累加器清零
            Q.rpos[arow]=Q.tu+1;
            if(arow<M.mu) tp=M.rpos[arow+1];
            else tp=M.tu+1;
            for(p=M.rpos[arow]; p<tp; ++p) { // 对当前行中每一个非零元
                brow=M.data[p].j;
                if(brow<N.mu) t=N.rpos[brow+1];
                else t=N.tu+1;
                for(q=N.rpos[brow]; q<t; ++q) {
                    ccol=N.data[q].j; // 乘积元素在Q中的列号
                    ctemp[ccol] += M.data[p].e*N.data[q].e;
                } // for q
            } // 求得Q中第crow(=arow)行的非零元
            for(ccol=1; ccol<=Q.nu; ++ccol) if(ctemp[ccol]) {
                if(++Q.tu>MAXSIZE) return ERROR;
                Q.data[Q.tu] = {arow, ccol, ctemp[ccol]};
            } // if
        } // for arow
    } // if
    return OK;
} // MultSMatrix
```

​	分析上述算法的时间复杂度. 累加器ctemp初始化时间复杂度为$O(M.mu\times N.nu)$, 求Q的所有非零元的时间复杂度为$O(M.tu\times N.tu/N.mu)$, 进行压缩存储的时间复杂度为$O(M.mu\times N.nu)$, 所以总的时间复杂度就是$O(M.mu\times N.nu+M.tu\times N.tu/N.mu)$. 若M是m行n列的稀疏矩阵, N是n行p列的稀疏矩阵, 则M中非零元的个数$M.tu=\delta_M\times m\times n$, N中非零元的个数$N.tu=\delta_N\times n\times p$, 相乘算法的时间复杂度就是$O(m\times p\times(1+n\delta_M\delta_N))$, 当$\delta_M<0.05$和$\delta_N<0.05$及$n<1000$时, 相乘算法的时间复杂度就相当于$O(m\times p)$. 

​	矩阵相乘的经典算法为:

``` c
for(i=1; i<=m1; ++i)
    for(j=1; j<=n2; ++j) {
        Q[i][j]=0;
        for(k=1; k<=n1; ++k) 
            Q[i][j] += M[i][k]*N[k][j];
    }
```

其时间复杂度为: $O(m1\times n2\times n1)$. 

## 5.3.3 十字链表

​	当矩阵的非零元个数和位置在操作过程中变化较大时, 例如矩阵相加操作, 要采用链式存储结构表示三元组的线性表. 

# 本章小结

1. 了解数组的两种存储表示方法, 并掌握数组在以行序为主序的存储结构中的地址计算方法; 
2. 掌握对特殊矩阵进行压缩存储时的下标变换公式; 
3. 了解稀疏矩阵的两种压缩存储方法的特点和适用范围, 领会以三元组表示稀疏矩阵时进行矩阵运算采用的处理方法. 
