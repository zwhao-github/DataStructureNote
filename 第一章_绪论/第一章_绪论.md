# 本章学习要点

1. 熟悉各名词、术语的含义, 掌握基本概念; 

2. 理解算法五个要素的确切含义; 

3. 掌握计算语句频度和估算算法时间复杂度的方法. 

# 1.1 数据结构讨论的范畴

程序 = 算法 + 数据结构

程序设计：为计算机处理问题编制一组指令集

算法：处理问题的策略

数据结构：问题的数学模型

通过实例，概括的说：

> **数据结构**是描述现实世界实体的数学模型（非数值计算）及其上的操作在计算机中的表示和实现。

# 1.2 基本概念

## 数据和数据结构

> **数据**：所有能被输入到计算机中，且被计算机处理的符号的集合。

数据是计算机操作对象的总称，是计算机处理的信息的某种特定的符号表示形式。

> **数据元素**：通常来说具有完整确定意义的, 描述现实某一客观实体的一个最小数据集(又叫结点, 顶点, 记录)等等, 种类繁多. 
> 
> **数据项**：数据结构中讨论的最小单位. 
> 
> **数据对象**: 性质相同的数据元素的集合, 是数据的一个子集. 

*数据元素*是数据中的一个“个体”，数据结构中讨论的基本单位（但不是最小单位）, 是数据项的集合。例如：出生日期数据元素，包含年、月、日三个数据项，称出生日期为*组合项*

> **数据结构**：带结构的数据元素的集合。

数据的*逻辑结构*可以归结为以下四类：

1. 线性结构
2. 树形结构
3. 图状结构
4. 集合结构

数据结构的定义形式为：数据结构是一个二元组$Data\_Structures = (D, S)$。其中，D是*数据元素的有限集*，S是D上*关系的有限集*。

以上方式仅反应了数据的其中一个方面，即*逻辑关系*。还有另一个方面，数据的*存储结构*。

> 数据的**存储结构**：逻辑结构在存储器中的*映象*。

由定义可知，数据的存储结构主要包括两方面的内容：数据元素的表示和关系的表示。

1. *数据元素*的映象方法：用二进制位（bit）的位串表示数据元素
2. *关系*的映象方法：两种，*顺序映象*和*非顺序映象*(或称为*链式映象*)

> 关系的映象方法即为表示<x,y>的方法。因为所有的关系都可以用一个有序对的集合表示，因此把有序对看成关系的基本单位。
> 
> > *顺序映象*：以数据元素在存储器之间固定的相对位置的关系来表示数据元素之间的关系
> 
> > *链式映象*：在整个结构中，x和y的存储位置之间没有固定的关系，他们的存储位置可以随意；以附加信息（指针）表示后继关系，`指针和元素x绑定在一起`

## 数据类型

在用高级程序语言编写的程序中，必须对程序中出现的每个变量、常量或表达式，明确说明他们多数的数据类型。每一个类型明显或者隐含的规定了在程序执行期间变量或者表达式所允许取值的范围以及允许进行的操作。

因此**数据类型**是`一个值的集合和定义在此集合上的一组操作的总称`。

数据类型有两种：*简单型*和*结构类型*。`在某种意义上，数据结构可以看成是“一组具有相同结构的值”，则结构类型可以看成一种数据结构和定义在其上的一组操作组成。`

## 抽象数据类型

*抽象数据类型*（ADT）是指一个数学模型（一个数据结构）以及定义在此数学模型上的一组操作。

ADT有两个重要特征：

> **数据的抽象性**：用ADT描述程序处理的实体时，强调的是其本质的特征、其所能完成的功能以及他和外部用户的结构（即外界使用他的方法。）
> 
> **数据的封装性**：将实体的外部特性和其内部的实线细节分离，并且对外部用户隐藏其内部的实线细节

比如一个复数的抽象数据类型：

> ADT Complex{
>
> ​	数据对象:
>
> ​		$D = \{e_1, e_2 | e_1, e_2\in RealSet\}$
>
> ​    数据关系:
>
> ​        $R1 = \{<e_1, e_2> | e_1是复数的实数部分, | e_2是复数的叙述部分 \}$
>
> ​    基本操作:
>
> ​        InitComplex(&Z, v1, v2)
>
> ​       	 操作结果:构造复数Z,其实部和虚部分别被赋以参数v1和v2的值.
>
> ​        DestroyComplex(&Z)
>
> ​        	操作结果:复数Z被销毁
>
> ​        GetReal(Z, &realPart)
>
> ​        	初始条件:复数已存在.
>
> ​        	操作结果:用realPart返回复数Z的实部值.
>
> ​        Getmag(Z, &ImagPart)
>
> ​        	初始条件:复数已存在.
>
> ​        	操作结果:用ImagPart返回复数Z的虚部值.
>
> ​        Add(z1, z2, &sum)
>
> ​        	初始条件:z1,z2是复数.
>
> ​        	操作结果:用sum返回两个复数z1和z2的和值.
>
> }

抽象数据类型的描述方法：（D，S，P）。其中D是数据对象，S是D上的关系集，P是对D的基本操作。不难看出D和S构成一个数据结构。

如果称高级程序设计语言中已有的数据类型为固有数据类型的话，那么抽象数据类型就需要借助固有数据类型来表示，并且借由固有数据类型中已实现的操作来实现抽象数据类型的操作。

# 1.3 算法和算法的衡量

## 算法

> **算法**：算法是对问题求解的一种描述，是为了解决某类问题而规定的一个有限长的操作序列。

1. 有穷性

2. 确定性

3. 可行性

4. 有输入

5. 有输出

### 有穷性

对于任意一组合法的输入值，在执行有穷步骤之后一定能结束。即：

- 算法的步骤是有限的
- 每个步骤都能在有限时间（或者表述为合理的时间）内完成

### 确定性

- 对于每一种情况,执行的操作在算法中有明确的规定.

- 在任何条件下,算法都只有一种执行路径(对同一种输入值,不管什么条件下,重复执行多遍,都能得到相同的结果)

### 可行性

- 算法中的所有操作都必须*足够基本*,都可以通过已经实现的基本操作运算有限次实现.

简单表述为: `让操作使得阅读者和执行者明确它的含义`. 例如求x, y的最大公因数; 增加变量x的值这两个操作就不够基本. 相反, 使得x+1或者交换x和y的值就为基本操作.

### 有输入

任何算法都必须要有输入. 输入的形式有多种: 可以通过终端输入或者通过函数的参数来实现. 有些算法表面上可以没有输入, 实际上已经被嵌入算法之中. 例如求100的阶乘, 并不需要输入100次. 话句话说, "*有输入*"表示`有加工的对象`.

### 有输出

他是一组与"输入"有确定关系的量值, 是算法进行信息加工后得到的结果, 这种确定关系即为算法的功能. 

## 算法设计的原则

1. 正确性

2. 可读性

3. 健壮性

4. 高效率与低存储量的需求

注意:

四项原则要依次满足, 即满足正确性的前提下在满足可读性, 依次类推. 

### 正确性

首先, 算法应当满足以特定的"规格说明"方式给出的需求. 

对算法是否**正确**的理解可以有以下几个层次:

- 程序中不含语法错误; 

- 程序对于几组输入数据能够得出满足要求的结果; 

- 程序对于`精心选择的、典型、苛刻切带有刁难性`的几组输入数据能够得出满足要求的结果; (通常作为衡量一个算法是否合格的标准)

- 对于一切合法的输入数据都能得出满足要求的结果. 

### 可读性

算法主要是为了人的阅读和交流用的, 因此算法应该更易于人的理解; 另一方面, 晦涩难读的程序易于隐藏较多错误而难以调试. 

### 健壮性

当`输入数据非法`时, 算法应当恰当地作出反映或者`进行相应处理`, 而不是产生莫名其妙的输出结果. 并且`处理出错的方法`应该是`返回一个表示错误或者错误性质的值`, 以便在更高的抽象层次上进行处理. 

### 高效率和低存储量的需求

**效率**指的是`算法执行的时间`; **存储量**指的是执行过程中`所需要的最大存储空间`. 两者都与问题的规模有关. 

    首先讨论高效率, 即**时间复杂度**. 

通常有两种**衡量算法效率**的方法: 

> **事后统计法**: 将算法编程为程序, 然后在计算机上执行并计时. 
> 
> **事前分析估算法**: 在设计算法的时候就可以对比两个算法的效率

事后统计法的缺点有: 

- 必须执行程序(要多次运算统计结果)

- 其他因素掩盖算法本质

鉴于以上缺点, 实际中更多的采用事前分析估计法. 首先要了解算法执行时间相关的因素: 

1. **算法采用的策略**

2. **问题的规模n** 问题的大小, 例如输入值的个数

3. 编写程序的语言

4. 编译程序产生的机器代码的质量

5. 计算机执行指令的速度

算法的执行时间取决于算法采用的策略和问题的规模, 也就是算法的执行时间是问题规模的函数. 

    事前算法估计的目的是要对`一般的问题来考虑`, 也就是当问题规模为n的时候, 若n的值绝对小, 也就不值得追究算法的执行时间了. 我们更关心的是随着问题规模n的增长, 算法执行时间的增长有什么样的趋势. 通常, 称这样一个函数为算法的**\(渐进\)时间复杂度**, 记作:

$$
T(n) = O(f(n)) \tag{1}
$$

其中, $f(n)$表示算法中`基本操作重复执行的次数`是问题规模n的某个函数$f(n)$. 

```diff
- 注意: 基本操作的概念在下文提出: 
```

> $O$的形式定义为: 若$f(n)$是正整数n的一个函数, 则$x_n = O(f(n))$表示存在一个正的常数M, 使得当$n\geqslant n_0$时都满足$\lvert x_n\rvert\leqslant M\lvert f(n)\rvert$. 

    上式表示, 当n增大时, 算法的执行时间随着n增大而增大的函数趋势和$f(n)$增大的趋势相同, 即算法执行时间的增长率和$f(n)$的增长率相同, 我们称算法的执行时间(时间复杂度)和函数$f(n)$成正比, 或者称算法的时间复杂度是$f(n)$函数数量级的. 

``` diff
- 注意: (以下为做题过程中自己总结以及网上查询资料得到, 不一定准确. 参考习题: 1.10, 1.14):
```

> 函数的增长趋势即为增长率;
> 
> 计算$f(n)$的增长率时, 可以带入$\frac{f(n+1) - f(n)}{f(n)}$. 即比较两个不同的函数增长率时, 可以比较$\frac{f(n+1)}{f(n)}$.
> 
> 比较复杂函数的增长率时, 可以利用放缩或者幂指变换等方法先计算复杂函数的阶数.

如果`计算时间复杂度`?

> 算法 = 控制结构(顺序, 分支和循环) + 原操作

    计算机执行的基本指令, 当使用伪码语言或者高级程序设计语言来描述算法时, 称**固有数据类型的操作**为**原操作**. 

    综上, $算法的执行时间 = \sum原操作(i)的执行次数\times原操作(i)的执行时间$

由于原操作(i)的执行时间对于不同的算法来说是一个*定值*, 因此在对比算法的时候忽略, 因此

> 算法的执行时间和原操作执行次数之和成正比. 

时间复杂度考虑的是随着n的增长, 算法执行时间增长的趋势, 即*增长率*. 因此每一个算法里有很多原操作, 我们不需要考虑所有的原操作, 只需要在原操作里选择一种对于所研究的问题来说是`基本操作`的原操作, 以该基本操作`在算法中执行的次数`作为算法运行时间的衡量标准. 

> **基本操作**是对于研究的问题来说在所有的原操作里要起*决定性作用*的原操作. 简单可以理解为执行次数最多的操作. 

例一: 

```c
for(i=1; i<=n; ++i)
    for(j=1; j<=n; ++j) {
        c[i][j] = 0;
        for(k=1; k<=n; ++k)
            c[i][j] += a[i][k] * b[k][j];
    }
```

上述算法表示两个$N\times N$矩阵相乘的算法. 上文提到: $算法=控制结构+原操作$. 改算法的控制结构为三层的循环, 原操作有赋值, 相加, 乘法. 显然, 乘法操作为改算法的基本操作, 因此乘法的操作次数可以作为算法时间复杂度的衡量标准. 因为控制结构为三层n次的循环, 所以乘法的执行次数为$n^3$, 整个算法的运行时间和$n^3$成正比, 称算法的时间复杂度为$O(n^3)$. 

例二: 

```c
void select_sort(int a[], int n) {
    // 将a中整数序列重新排列成自小至大有序的整数序列
    for(i=0; i<n-1; ++i) {
        j = i;
        for(k=i+1; k<n; ++k)
            if(a[k]<a[j]) j=k;
        if(j!=i) a[j]←→ a[i];
    }
} // select_sort
```

上述算法表示选择排序的算法. 显然, 改算法的控制结构为两层的循环, 原操作有比较, 赋值和交换, <u>基本操作</u>为<u>两个数据元素的比较</u>. 比较操作的次数为: $(n-1) + (n-2) + (n-3) + \cdots + 1$, 即$\frac{n(n-1)}{2}$, 即算法的执行时间和$\frac{n^2-n}{2}$成正比, 也就是和$n^2$成正比, 所以算法的之间复杂度为$O(n^2)$. 

> 对于一个正常数C, 一个算法在时间C的$n^2$内, 能够处理规模为n的输入, 则称该算法的时间复杂度为$n^2$阶. 

从上述两例可以看出, 一般情况下, 算法的基本操作都是在生成的循环语句当中的. 称语句的执行次数为语句的**频度**. 有时也可以在估算算法时间复杂度时, 计算最深层循环语句的频度, 来作为算法的时间复杂度. 

    上例两个算法的时间复杂度和输入无关, 它只是问题规模的函数. 但有的算法并不是这样. 

例三: 

```c
void bubble_sort(int a[], int n) {
    // 将a中整数序列重新排列成自小至大有序的整数序列
    for(i=n-1,change=TRUE; i>=1&&change; --i) {
        change = FALSE;
        for(j=0; j<i; ++j)
            if(a[j]>a[j+1]) {a[j]←→a[j+1]; change=TRUE; }
    }
} // bubble_sort
```

上述算法为冒泡排序的算法, 算法中引入了change标签来判断一个序列是否已经从小到大排序. 算法的基本操作为**赋值操作**(或者表述为交换序列中相邻两个整数为基本操作, 但交换操作本质还是赋值操作). 基本操作执行次数`不光和n有关, 还和输入的数据有关`. 如果输入a为自小至大的有序序列, 那么基本操作的执行次数为0; 反之如果为自大到小的序列, 则基本操作的执行次数和选择排序一样为$\frac{n^2-n}{2}$. `在一般没有说明的情况下, 考虑时间复杂度时以最坏的情况为准`, 因为最大的执行次数为$\frac{n^2-n}{2}$, 所以冒泡排序算法的时间复杂度为$O(n^2)$. 

    有些情况下也可以考虑平均时间复杂度. 如例三, 假设初试的序列a为随机的, 即初试输入数据可能有$n!$种排列方式, 每种方式出现的概率相同. 这时选用最好情况的时间复杂度和最坏情况的时间复杂度来求平均(求和除2)来作为算法的时间复杂度. 显然例三中平均时间复杂度仍然为$T_{arg}(n) = O(n^2)$. 以后课程讨论的时间复杂度均为最坏情况下的时间复杂度. 

    接着讨论低存储量的需求, 即**空间复杂度**的计算. 

与时间复杂度类似, 算法的空间复杂度也指的是算法的(渐进)空间复杂度, 记作: 

$$
S(n) = O(g(n)) \tag{2}
$$

其中n为问题的规模. 上式表示随着问题规模n的增大, `算法运行所需存储量的增长率`与$g(n)$的`增长率`相同. 

**算法的存储量**包括: 

- 输入数据所占空间

- 程序本身所占空间

- 辅助变量所占空间

    一般来说, 不同的程序所占的空间不同, 但差别并不大, 所以在比较不同算法的空间复杂度时可以不考虑程序本身所占空间. 同时, `若输入数据所占空间只取决于问题本身, 和算法无关`(也就是不管用什么算法, 如果处理的问题相同, 输入数据所占空间也就相同. 例如上文的例二和例三, 不同的排序算法, 但是输入相同. 因此这种情况下考虑输入数据所占空间对于比较算法的空间复杂度并无帮助), 则只需要分析`除输入和程序之外的辅助变量所占额外空间`. 

    若所需额外空间相对于输入数据量来说是常数, 则称此算法为**原地工作**, 算法的空间复杂度为$O(1)$. 例如例二例三中的i, j, change. 

    当所占空间量依赖于特定的输入, 则除特别指明外, 均按最坏情况来计算. 

# 思考题

给两个函数, $n^2$和$50nlog_2n$, 比较他们的增长的趋势($n\rightarrow +\infty$), 并且确定n在什么范围内各自的大小. (也就是求什么时候$n>50log_2n$. )即数据结构C语言版习题1.13. 
