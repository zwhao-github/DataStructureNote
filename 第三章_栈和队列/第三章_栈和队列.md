从数据结构的角度来看, 栈和队列也是线性表, 但从类型来看, 它们是不同的, 即操作不一样. 

# 3.1 栈的类型定义

**栈**是限定仅在表尾进行插入或删除操作的线性表. 因此, 对于栈来说, 表尾端有其特殊含义, 称为`栈顶(top)`, 相应地, 表头端称为`栈底(bottom)`. 不含元素的空表称为空栈. 

| 操作名称 | 线性表                                                       | 栈                | 队列              |
| -------- | ------------------------------------------------------------ | ----------------- | ----------------- |
| 插入     | ListInsert(L, i, e), $1\leqslant i\leqslant ListLength(L)+1$; | Insert(S, n+1, e) | Insert(Q, n+1, e) |
| 删除     | ListDelete(L, i, &e), $1\leqslant i\leqslant ListLength(L)$; | Delete(S, n, &e)  | Delete(Q, 1, &e)  |

抽象数据类型栈的定义: 

> ADT Stack{
>
> ​	数据对象: $D = \{a_i|a_i\in ElemSet, i=1, 2, \cdots, n, n\geqslant0\}$; 
>
> ​	数据关系: $R1 = \{<a_{i-1}, a_i>|a_{i-1}, a_i\in D, i=2, \cdots, n\}$, 约定$a_n$端为栈顶, $a_1$端为栈底; 
>
> ​	基本操作: 
>
> ​		InitStack(&S)
>
> ​			操作结果: 构造一个空栈S. 
>
> ​		DestroyStack(&S)
>
> ​			初试条件: 栈S已存在. 
>
> ​			操作结果: 栈S被销毁. 
>
> ​		StackEmpty(S)
>
> ​			初试条件: 栈S已存在. 
>
> ​			操作结果: 若栈S为空栈, 则返回TRUE; 否则返回FALSE. 
>
> ​		StackLength(S)
>
> ​			初试条件: 栈S已存在. 
>
> ​			操作结果: 返回S的元素个数, 即栈的长度. 
>
> ​		GetTop(S, &e)
>
> ​			初试条件: 栈S已存在且非空. 
>
> ​			操作结果: 用e返回S的栈顶元素. 
>
> ​		ClearStack(&S)
>
> ​			初试条件: 栈S已存在. 
>
> ​			操作结果: 将S清为空栈. 
>
> ​		Push(&S, e)
>
> ​			初试条件: 栈S已存在. 
>
> ​			操作结果: 插入元素e为新的栈顶元素. 
>
> ​		Pop(&S, &e)
>
> ​			初试条件: 栈S已存在且非空. 
>
> ​			操作结果: 删除S的栈顶元素, 并用e返回其值. 
>
> ​		StackTraverse(S, visit())
>
> ​			初试条件: 栈S已存在且非空. 
>
> ​			操作结果: 从栈顶到栈底依次对S的每个数据元素调用函数visit(). 一旦visit()失败, 则操作失效. 
>
> }ADT Stack

# 3.2 栈的应用举例

​	在实际应用中, 栈的应用非常广泛. 如果某一个问题经过分析发现求解的过程中有后进先出的特点, 那么就可以考虑使用栈结构来解决这个问题. 以下举出六个例子. 

## 3.2.1 数制转换

算法基于下列原理: 
$$
N = (N/d)\times d + N\ mod\ d.
$$
例如: $(1348)_{10} = (2504)_8$, 其运算过程如下: 

| $N$  | $N/8$ | $N\ mod\ 8$ |
| ---- | ----- | ----------- |
| 1348 | 168   | 4           |
| 168  | 21    | 0           |
| 21   | 2     | 5           |
| 2    | 0     | 2           |

上述计算过程是从上到下的, 但是输出结果确实从下往上打印输出. 因此使用栈实现上述操作较为合理. 

``` c
void conversion() {
    // 对于输入的任意一个非负十进制数, 打印输出与其等值的八进制数
    InitStack(S); // 构造空栈
    scanf("%d", N):
    while (N){
        Push(S, N%8);
        N = N/8;
    }
    while (!StackEmpty(S)) {
        Pop(S, e);
        printf("%d", e);
    }
} // conversion
```

栈的引入简化了程序设计的问题, 划分了不同的关注层次, 使思考范围缩小. 若使用数组不仅掩盖了问题的本质, 还要分散精力去考虑数组下标增减等细节问题, 程序可读性较差. 

## 3.2.2 括号匹配检测

​	检验括号是否匹配的方法用`期待的急迫程度`这个概念来描述, 且期待程度随着另外一个括弧的出现而减弱. 在设计算法时, 要弄清楚什么情况为错误情况, 主要归纳为如下三种: [(])、(()])、([()). 反应到栈中则是如下几种情况: 

- 到来的右括弧`不是所"期待"`的;
- 到来的是`"不速之客"`;
- 直到结束, 也`没有到来所"期待"`的. 

综上, 算法的设计思想如下: 

1. 凡出现左括弧, 则进栈;
2. 凡出现右括弧, 首先检查栈是否空. 若栈空, 则表明"右括弧"多了; 否则和栈顶元素比较, 若匹配, 则"左括弧出栈", 否则不匹配;
3. 表达式检验结束时, 若栈空, 则匹配正确, 否则表明左括弧多了. 

``` c
Status matching(string &exp) {
    int state = 1;
    InitStack(S);
    while (i<=Length(exp) && state) {
        switch of exp[i] {
            case 左括弧:{Push(S, exp[i]); i++; break;}
            case ")":{
                if (NOT StackEmpty(S) && GetTop(S)="(") {Pop(S, e); i++;}
                else state = 0;
                break;
            }
                ... ...
        }
    }
    if (StackEmpty(S) && state) return OK;
    else return ERROR;
}
```



## 3.2.3 行编辑程序问题

​	一个简单的行编辑程序的功能是: 接受用户从终端输入的程序或数据, 并存入用户的数据区. 较好的做法是, 设立一个缓冲区, 用以接收用户输入的一行字符, 然后逐行存入用户数据区. 允许用户输入出差错, 并在发现有误时可以即使更正. 设立退格符"#"、退行符"@". 

``` c
void LineEdit() {
    // 利用字符栈S, 从终端接收一行并传送至调用过程的数据区
    InitStack(S);	// 构造空栈S
    ch = getchar();	// 从终端接收第一个字符
    while(ch != EOF) { // EOF为全文结束符
        while (ch != EOF && ch != '\n') {
            switch(ch) {
                case '#':Pop(S, c); break; // 仅当栈非空时退栈
                case '@':ClearStack(S);	break; // 重置S为空栈
                default:Push(S, ch);	break; // 有效字符进栈, 未考虑栈满情形
            }
            ch = getchar(); // 从终端接收下一个字符
        }
        将从栈底到栈顶的栈内字符传送至调用过程的数据区;
        ClearStack(S); // 重置S为空栈
        if(ch != EOF) ch = getchar();
    }
    DestroyStack(S);
} // LineEdit
```

## 3.2.4 迷宫求解

求迷宫路径算法的基本思想是: 

- 若当前位置"可通", 则纳入路径, 继续前进;
- 若当前位置"不可通", 则后退, 换向探索;
- 若四周均"不可通", 则从路径中删除. 

算法可简单用文字描述如下:

> **do** {
>
> ​	**若**当前位置可通, 
>
> ​	**则** {
>
> ​		将当前位置插入栈顶;	// 纳入路径
>
> ​		若该位置是出口位置, 则结束;	// 求得路径存放在栈中
>
> ​		否则切换当前位置的东邻方块为新的当前位置; 
>
> ​	}
>
> ​	**否则**, 
>
> ​		**若**栈不空且栈顶位置尚有其他方向为经探索, 
>
> ​			**则**设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一相邻快;
>
> ​		**若**栈不空但栈顶位置的四周均不可通, 
>
> ​			**则** {
>
> ​				删去栈顶位置; 	// 从路径中删除该通道块
>
> ​				**若**栈不空, 则重新测试新的栈顶位置, 直至找到一个可通的相邻块或出栈至栈空; 
>
> ​			}
>
> } **while**(栈不空);

